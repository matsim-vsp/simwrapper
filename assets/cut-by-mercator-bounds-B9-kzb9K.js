import{_ as v,n as T,o as D,q as F,k as Y,B as k}from"./set-rtl-text-plugin-FQQ7PIy4.js";class K{constructor(t){v(this,"opts",void 0),v(this,"typedArrayManager",void 0),v(this,"indexStarts",[0]),v(this,"vertexStarts",[0]),v(this,"vertexCount",0),v(this,"instanceCount",0),v(this,"attributes",void 0),v(this,"_attributeDefs",void 0),v(this,"data",void 0),v(this,"getGeometry",void 0),v(this,"geometryBuffer",void 0),v(this,"buffers",void 0),v(this,"positionSize",void 0),v(this,"normalize",void 0);const{attributes:e={}}=t;this.typedArrayManager=T,this.attributes={},this._attributeDefs=e,this.opts=t,this.updateGeometry(t)}updateGeometry(t){Object.assign(this.opts,t);const{data:e,buffers:n={},getGeometry:r,geometryBuffer:o,positionFormat:i,dataChanged:l,normalize:y=!0}=this.opts;if(this.data=e,this.getGeometry=r,this.positionSize=o&&o.size||(i==="XY"?2:3),this.buffers=n,this.normalize=y,o&&(D(e.startIndices),this.getGeometry=this.getGeometryFromBuffer(o),y||(n.positions=o)),this.geometryBuffer=n.positions,Array.isArray(l))for(const c of l)this._rebuildGeometry(c);else this._rebuildGeometry()}updatePartialGeometry({startRow:t,endRow:e}){this._rebuildGeometry({startRow:t,endRow:e})}getGeometryFromBuffer(t){const e=t.value||t;return ArrayBuffer.isView(e)?F(e,{size:this.positionSize,offset:t.offset,stride:t.stride,startIndices:this.data.startIndices}):null}_allocate(t,e){const{attributes:n,buffers:r,_attributeDefs:o,typedArrayManager:i}=this;for(const l in o)if(l in r)i.release(n[l]),n[l]=null;else{const y=o[l];y.copy=e,n[l]=i.allocate(n[l],t,y)}}_forEachGeometry(t,e,n){const{data:r,getGeometry:o}=this,{iterable:i,objectInfo:l}=Y(r,e,n);for(const y of i){l.index++;const c=o?o(y,l):null;t(c,l.index)}}_rebuildGeometry(t){if(!this.data)return;let{indexStarts:e,vertexStarts:n,instanceCount:r}=this;const{data:o,geometryBuffer:i}=this,{startRow:l=0,endRow:y=1/0}=t||{},c={};if(t||(e=[0],n=[0]),this.normalize||!i)this._forEachGeometry((f,h)=>{const u=f&&this.normalizeGeometry(f);c[h]=u,n[h+1]=n[h]+(u?this.getGeometrySize(u):0)},l,y),r=n[n.length-1];else if(n=o.startIndices,r=n[o.length]||0,ArrayBuffer.isView(i))r=r||i.length/this.positionSize;else if(i instanceof k){const f=i.accessor.stride||this.positionSize*4;r=r||i.byteLength/f}else if(i.buffer){const f=i.stride||this.positionSize*4;r=r||i.buffer.byteLength/f}else if(i.value){const f=i.value,h=i.stride/f.BYTES_PER_ELEMENT||this.positionSize;r=r||f.length/h}this._allocate(r,!!t),this.indexStarts=e,this.vertexStarts=n,this.instanceCount=r;const p={};this._forEachGeometry((f,h)=>{const u=c[h]||f;p.vertexStart=n[h],p.indexStart=e[h];const d=h<n.length-1?n[h+1]:r;p.geometrySize=d-n[h],p.geometryIndex=h,this.updateGeometryAttributes(u,p)},l,y),this.vertexCount=e[e.length-1]}}function S(s,t){const e=t.length,n=s.length;if(n>0){let r=!0;for(let o=0;o<e;o++)if(s[n-e+o]!==t[o]){r=!1;break}if(r)return!1}for(let r=0;r<e;r++)s[n+r]=t[r];return!0}function I(s,t){const e=t.length;for(let n=0;n<e;n++)s[n]=t[n]}function P(s,t,e,n,r=[]){const o=n+t*e;for(let i=0;i<e;i++)r[i]=s[o+i];return r}function M(s,t,e,n,r=[]){let o,i;if(e&8)o=(n[3]-s[1])/(t[1]-s[1]),i=3;else if(e&4)o=(n[1]-s[1])/(t[1]-s[1]),i=1;else if(e&2)o=(n[2]-s[0])/(t[0]-s[0]),i=2;else if(e&1)o=(n[0]-s[0])/(t[0]-s[0]),i=0;else return null;for(let l=0;l<s.length;l++)r[l]=(i&1)===l?n[i]:o*(t[l]-s[l])+s[l];return r}function _(s,t){let e=0;return s[0]<t[0]?e|=1:s[0]>t[2]&&(e|=2),s[1]<t[1]?e|=4:s[1]>t[3]&&(e|=8),e}function H(s,t){const{size:e=2,broken:n=!1,gridResolution:r=10,gridOffset:o=[0,0],startIndex:i=0,endIndex:l=s.length}=t||{},y=(l-i)/e;let c=[];const p=[c],f=P(s,0,e,i);let h,u;const d=w(f,r,o,[]),a=[];S(c,f);for(let g=1;g<y;g++){for(h=P(s,g,e,i,h),u=_(h,d);u;){M(f,h,u,d,a);const m=_(a,d);m&&(M(f,a,m,d,a),u=m),S(c,a),I(f,a),j(d,r,u),n&&c.length>e&&(c=[],p.push(c),S(c,f)),u=_(h,d)}S(c,h),I(f,h)}return n?p:p[0]}const E=0,V=1;function B(s,t){for(let e=0;e<t.length;e++)s.push(t[e]);return s}function X(s,t=null,e){if(!s.length)return[];const{size:n=2,gridResolution:r=10,gridOffset:o=[0,0],edgeTypes:i=!1}=e||{},l=[],y=[{pos:s,types:i?new Array(s.length/n).fill(V):null,holes:t||[]}],c=[[],[]];let p=[];for(;y.length;){const{pos:f,types:h,holes:u}=y.shift();N(f,n,u[0]||f.length,c),p=w(c[0],r,o,p);const d=_(c[1],p);if(d){let a=L(f,h,n,0,u[0]||f.length,p,d);const g={pos:a[0].pos,types:a[0].types,holes:[]},m={pos:a[1].pos,types:a[1].types,holes:[]};y.push(g,m);for(let G=0;G<u.length;G++)a=L(f,h,n,u[G],u[G+1]||f.length,p,d),a[0]&&(g.holes.push(g.pos.length),g.pos=B(g.pos,a[0].pos),i&&(g.types=B(g.types,a[0].types))),a[1]&&(m.holes.push(m.pos.length),m.pos=B(m.pos,a[1].pos),i&&(m.types=B(m.types,a[1].types)))}else{const a={positions:f};i&&(a.edgeTypes=h),u.length&&(a.holeIndices=u),l.push(a)}}return l}function L(s,t,e,n,r,o,i){const l=(r-n)/e,y=[],c=[],p=[],f=[],h=[];let u,d,a;const g=P(s,l-1,e,n);let m=Math.sign(i&8?g[1]-o[3]:g[0]-o[2]),G=t&&t[l-1],b=0,A=0;for(let z=0;z<l;z++)u=P(s,z,e,n,u),d=Math.sign(i&8?u[1]-o[3]:u[0]-o[2]),a=t&&t[n/e+z],d&&m&&m!==d&&(M(g,u,i,o,h),S(y,h)&&p.push(G),S(c,h)&&f.push(G)),d<=0?(S(y,u)&&p.push(a),b-=d):p.length&&(p[p.length-1]=E),d>=0?(S(c,u)&&f.push(a),A+=d):f.length&&(f[f.length-1]=E),I(g,u),m=d,G=a;return[b?{pos:y,types:t&&p}:null,A?{pos:c,types:t&&f}:null]}function w(s,t,e,n){const r=Math.floor((s[0]-e[0])/t)*t+e[0],o=Math.floor((s[1]-e[1])/t)*t+e[1];return n[0]=r,n[1]=o,n[2]=r+t,n[3]=o+t,n}function j(s,t,e){e&8?(s[1]+=t,s[3]+=t):e&4?(s[1]-=t,s[3]-=t):e&2?(s[0]+=t,s[2]+=t):e&1&&(s[0]-=t,s[2]-=t)}function N(s,t,e,n){let r=1/0,o=-1/0,i=1/0,l=-1/0;for(let y=0;y<e;y+=t){const c=s[y],p=s[y+1];r=c<r?c:r,o=c>o?c:o,i=p<i?p:i,l=p>l?p:l}return n[0][0]=r,n[0][1]=i,n[1][0]=o,n[1][1]=l,n}const O=85.051129;function Q(s,t){const{size:e=2,startIndex:n=0,endIndex:r=s.length,normalize:o=!0}=t||{},i=s.slice(n,r);x(i,e,0,r-n);const l=H(i,{size:e,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(o)for(const y of l)C(y,e);return l}function W(s,t=null,e){const{size:n=2,normalize:r=!0,edgeTypes:o=!1}=e||{};t=t||[];const i=[],l=[];let y=0,c=0;for(let f=0;f<=t.length;f++){const h=t[f]||s.length,u=c,d=q(s,n,y,h);for(let a=d;a<h;a++)i[c++]=s[a];for(let a=y;a<d;a++)i[c++]=s[a];x(i,n,u,c),U(i,n,u,c,e?.maxLatitude),y=h,l[f]=c}l.pop();const p=X(i,l,{size:n,gridResolution:360,gridOffset:[-180,-180],edgeTypes:o});if(r)for(const f of p)C(f.positions,n);return p}function q(s,t,e,n){let r=-1,o=-1;for(let i=e+1;i<n;i+=t){const l=Math.abs(s[i]);l>r&&(r=l,o=i-1)}return o}function U(s,t,e,n,r=O){const o=s[e],i=s[n-t];if(Math.abs(o-i)>180){const l=P(s,0,t,e);l[0]+=Math.round((i-o)/360)*360,S(s,l),l[1]=Math.sign(l[1])*r,S(s,l),l[0]=o,S(s,l)}}function x(s,t,e,n){let r=s[0],o;for(let i=e;i<n;i+=t){o=s[i];const l=o-r;(l>180||l<-180)&&(o-=Math.round(l/360)*360),s[i]=r=o}}function C(s,t){let e;const n=s.length/t;for(let o=0;o<n&&(e=s[o*t],(e+180)%360===0);o++);const r=-Math.round(e/360)*360;if(r!==0)for(let o=0;o<n;o++)s[o*t]+=r}export{K as T,Q as a,X as b,H as c,W as d};
